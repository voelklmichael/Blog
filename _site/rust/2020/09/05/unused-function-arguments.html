<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.6.1 -->
<title>Zero cost abstractions: Unused arguments in Rust | My blog</title>
<meta name="generator" content="Jekyll v4.1.1" />
<meta property="og:title" content="Zero cost abstractions: Unused arguments in Rust" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Topic This short entry is a longer answer to stackoverflow. The questions is: Is there a (negative) performance impact due to unused function arguments (in Rust)? Claim: There is no runtime performance impact. The compiler removes all unused function arguments (in release mode)." />
<meta property="og:description" content="Topic This short entry is a longer answer to stackoverflow. The questions is: Is there a (negative) performance impact due to unused function arguments (in Rust)? Claim: There is no runtime performance impact. The compiler removes all unused function arguments (in release mode)." />
<link rel="canonical" href="http://localhost:4000/rust/2020/09/05/unused-function-arguments.html" />
<meta property="og:url" content="http://localhost:4000/rust/2020/09/05/unused-function-arguments.html" />
<meta property="og:site_name" content="My blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2020-09-05T14:14:18+02:00" />
<script type="application/ld+json">
{"@type":"BlogPosting","url":"http://localhost:4000/rust/2020/09/05/unused-function-arguments.html","headline":"Zero cost abstractions: Unused arguments in Rust","dateModified":"2020-09-05T14:14:18+02:00","datePublished":"2020-09-05T14:14:18+02:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/rust/2020/09/05/unused-function-arguments.html"},"description":"Topic This short entry is a longer answer to stackoverflow. The questions is: Is there a (negative) performance impact due to unused function arguments (in Rust)? Claim: There is no runtime performance impact. The compiler removes all unused function arguments (in release mode).","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="My blog" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">My blog</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <h1>Topic</h1>
<p>This short entry is a longer answer to <a href="https://stackoverflow.com/questions/63697356/will-rust-optimize-away-unused-function-arguments">stackoverflow</a>.
<br />
The questions is:
<br />
<b>
Is there a (negative) performance impact due to unused function arguments (in Rust)?</b>
<br />
Claim: There is no runtime performance impact. The compiler removes all unused function arguments (in release mode).</p>

<h1>Free Functions</h1>
<p>To this end, we will consider the following three functions:</p>

<figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">single_argument</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">u32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">u32</span> <span class="p">{</span>
    <span class="n">x</span> <span class="o">+</span> <span class="mi">424242</span>
<span class="p">}</span>
<span class="k">fn</span> <span class="nf">too_many_arguments</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="nb">u32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">u32</span> <span class="p">{</span>
    <span class="n">x</span> <span class="o">+</span> <span class="mi">424242</span>
<span class="p">}</span>
<span class="k">fn</span> <span class="nf">enough_arguments</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="nb">u32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">u32</span> <span class="p">{</span>
    <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
<span class="p">}</span></code></pre></figure>

<p>Lets have a look at the generate assembly (<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=0df6168f1becd11062f6c51cd9aabfde">playground_1</a>):</p>

<figure class="highlight"><pre><code class="language-sass" data-lang="sass"><span class="na">playground</span><span class="p">:</span><span class="o">:</span><span class="n">single_argument</span><span class="o">:</span>
	<span class="nt">pushq</span>	<span class="nv">%rax</span>
	<span class="nt">movl</span>	<span class="nv">%edi</span><span class="o">,</span> <span class="nt">4</span><span class="o">(</span><span class="nv">%rsp</span><span class="o">)</span>
	<span class="nt">addl</span>	<span class="err">$</span><span class="nt">424242</span><span class="o">,</span> <span class="nv">%edi</span>
	<span class="nt">setb</span>	<span class="nv">%al</span>
	<span class="nt">testb</span>	<span class="err">$</span><span class="nt">1</span><span class="o">,</span> <span class="nv">%al</span>
	<span class="nt">movl</span>	<span class="nv">%edi</span><span class="o">,</span> <span class="o">(</span><span class="nv">%rsp</span><span class="o">)</span>
	<span class="nt">jne</span>	<span class="nc">.LBB0_2</span>
	<span class="nt">movl</span>	<span class="o">(</span><span class="nv">%rsp</span><span class="o">),</span> <span class="nv">%eax</span>
	<span class="nt">popq</span>	<span class="nv">%rcx</span>
	<span class="nt">retq</span>

<span class="na">playground</span><span class="p">:</span><span class="o">:</span><span class="n">too_many_arguments</span><span class="o">:</span>
	<span class="nt">subq</span>	<span class="err">$</span><span class="nt">24</span><span class="o">,</span> <span class="nv">%rsp</span>
	<span class="nt">movl</span>	<span class="nv">%edi</span><span class="o">,</span> <span class="nt">16</span><span class="o">(</span><span class="nv">%rsp</span><span class="o">)</span>
	<span class="nt">movl</span>	<span class="nv">%esi</span><span class="o">,</span> <span class="nt">20</span><span class="o">(</span><span class="nv">%rsp</span><span class="o">)</span>
	<span class="nt">addl</span>	<span class="err">$</span><span class="nt">424242</span><span class="o">,</span> <span class="nv">%edi</span>
	<span class="nt">setb</span>	<span class="nv">%al</span>
	<span class="nt">testb</span>	<span class="err">$</span><span class="nt">1</span><span class="o">,</span> <span class="nv">%al</span>
	<span class="nt">movl</span>	<span class="nv">%edi</span><span class="o">,</span> <span class="nt">12</span><span class="o">(</span><span class="nv">%rsp</span><span class="o">)</span>
	<span class="nt">jne</span>	<span class="nc">.LBB1_2</span>
	<span class="nt">movl</span>	<span class="nt">12</span><span class="o">(</span><span class="nv">%rsp</span><span class="o">),</span> <span class="nv">%eax</span>
	<span class="nt">addq</span>	<span class="err">$</span><span class="nt">24</span><span class="o">,</span> <span class="nv">%rsp</span>
	<span class="nt">retq</span>

<span class="na">playground</span><span class="p">:</span><span class="o">:</span><span class="n">enough_arguments</span><span class="o">:</span>
	<span class="nt">subq</span>	<span class="err">$</span><span class="nt">24</span><span class="o">,</span> <span class="nv">%rsp</span>
	<span class="nt">movl</span>	<span class="nv">%edi</span><span class="o">,</span> <span class="nt">16</span><span class="o">(</span><span class="nv">%rsp</span><span class="o">)</span>
	<span class="nt">movl</span>	<span class="nv">%esi</span><span class="o">,</span> <span class="nt">20</span><span class="o">(</span><span class="nv">%rsp</span><span class="o">)</span>
	<span class="nt">addl</span>	<span class="nv">%esi</span><span class="o">,</span> <span class="nv">%edi</span>
	<span class="nt">setb</span>	<span class="nv">%al</span>
	<span class="nt">testb</span>	<span class="err">$</span><span class="nt">1</span><span class="o">,</span> <span class="nv">%al</span>
	<span class="nt">movl</span>	<span class="nv">%edi</span><span class="o">,</span> <span class="nt">12</span><span class="o">(</span><span class="nv">%rsp</span><span class="o">)</span>
	<span class="nt">jne</span>	<span class="nc">.LBB2_2</span>
	<span class="nt">movl</span>	<span class="nt">12</span><span class="o">(</span><span class="nv">%rsp</span><span class="o">),</span> <span class="nv">%eax</span>
	<span class="nt">addq</span>	<span class="err">$</span><span class="nt">24</span><span class="o">,</span> <span class="nv">%rsp</span>
	<span class="nt">retq</span></code></pre></figure>

<p>Since this is a bit much to understand, release mode:</p>

<figure class="highlight"><pre><code class="language-sass" data-lang="sass"><span class="na">playground</span><span class="p">:</span><span class="o">:</span><span class="n">single_argument</span><span class="o">:</span>
	<span class="nt">leal</span>	<span class="nt">424242</span><span class="o">(</span><span class="nv">%rdi</span><span class="o">),</span> <span class="nv">%eax</span>
	<span class="nt">retq</span>

<span class="na">playground</span><span class="p">:</span><span class="o">:</span><span class="n">too_many_arguments</span><span class="o">:</span>
	<span class="nt">leal</span>	<span class="nt">424242</span><span class="o">(</span><span class="nv">%rdi</span><span class="o">),</span> <span class="nv">%eax</span>
	<span class="nt">retq</span>

<span class="na">playground</span><span class="p">:</span><span class="o">:</span><span class="n">enough_arguments</span><span class="o">:</span>
	<span class="nt">leal</span>	<span class="o">(</span><span class="nv">%rdi</span><span class="o">,</span><span class="nv">%rsi</span><span class="o">),</span> <span class="nv">%eax</span>
	<span class="nt">retq</span></code></pre></figure>

<p>As promised, no difference between <b>single_argument</b> &amp; <b>too_many_arguments</b>.
I guess (I’m not an assembly expert), that in debug mode <b>too_many_arguments</b> writes its argument <b>y</b> into a register.</p>

<p>Last check: We want to check there is some overhead at the call site.
Note that the following example forbids inlining and uses each function twice to ensure that the compiler does not replace function calls by their return values.</p>

<figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="nd">#[inline(never)]</span>
<span class="nd">#[no_mangle]</span>
<span class="k">fn</span> <span class="nf">single_argument</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">u32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">u32</span> <span class="p">{</span>
    <span class="n">x</span> <span class="o">+</span> <span class="mi">424242</span>
<span class="p">}</span>

<span class="nd">#[inline(never)]</span>
<span class="nd">#[no_mangle]</span>
<span class="k">fn</span> <span class="nf">too_many_arguments</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="nb">u32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">u32</span> <span class="p">{</span>
    <span class="n">x</span> <span class="o">+</span> <span class="mi">424242</span>
<span class="p">}</span>

<span class="nd">#[inline(never)]</span>
<span class="nd">#[no_mangle]</span>
<span class="k">fn</span> <span class="nf">enough_arguments</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="nb">u32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">u32</span> <span class="p">{</span>
    <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"Result: {:?}"</span><span class="p">,</span> <span class="nf">too_many_arguments</span><span class="p">(</span><span class="mi">112</span><span class="p">,</span> <span class="mi">113</span><span class="p">));</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"Result: {:?}"</span><span class="p">,</span> <span class="nf">enough_arguments</span><span class="p">(</span><span class="mi">114</span><span class="p">,</span> <span class="mi">115</span><span class="p">),);</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"Result: {:?}"</span><span class="p">,</span> <span class="nf">single_argument</span><span class="p">(</span><span class="mi">116</span><span class="p">));</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"Result: {:?}"</span><span class="p">,</span> <span class="nf">too_many_arguments</span><span class="p">(</span><span class="mi">117</span><span class="p">,</span> <span class="mi">118</span><span class="p">));</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"Result: {:?}"</span><span class="p">,</span> <span class="nf">enough_arguments</span><span class="p">(</span><span class="mi">119</span><span class="p">,</span> <span class="mi">120</span><span class="p">),);</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"Result: {:?}"</span><span class="p">,</span> <span class="nf">single_argument</span><span class="p">(</span><span class="mi">121</span><span class="p">));</span>
<span class="p">}</span></code></pre></figure>

<p>And the generated assembly (in release mode):</p>

<figure class="highlight"><pre><code class="language-sass" data-lang="sass"><span class="na">playground</span><span class="p">:</span><span class="o">:</span><span class="n">main</span><span class="o">:</span>
  <span class="cm">/* unimportant */	 	
</span>  <span class="nt">movl</span>	<span class="err">$</span><span class="nt">112</span><span class="o">,</span> <span class="nv">%edi</span>
	<span class="nt">callq</span>	<span class="nt">too_many_arguments</span>
  <span class="cm">/* unimportant */	 	
</span>  <span class="nt">movl</span>	<span class="err">$</span><span class="nt">114</span><span class="o">,</span> <span class="nv">%edi</span>
	<span class="nt">movl</span>	<span class="err">$</span><span class="nt">115</span><span class="o">,</span> <span class="nv">%esi</span>
	<span class="nt">callq</span>	<span class="nt">enough_arguments</span>
	<span class="cm">/* unimportant */	   	
</span>  <span class="nt">movl</span>	<span class="err">$</span><span class="nt">116</span><span class="o">,</span> <span class="nv">%edi</span>
	<span class="nt">callq</span>	<span class="nt">single_argument</span>
	<span class="cm">/* unimportant */	 	
</span>  <span class="nt">movl</span>	<span class="err">$</span><span class="nt">117</span><span class="o">,</span> <span class="nv">%edi</span>
	<span class="nt">callq</span>	<span class="nt">too_many_arguments</span>
	<span class="cm">/* unimportant */	 
</span>  <span class="nt">movl</span>	<span class="err">$</span><span class="nt">119</span><span class="o">,</span> <span class="nv">%edi</span>
	<span class="nt">movl</span>	<span class="err">$</span><span class="nt">120</span><span class="o">,</span> <span class="nv">%esi</span>
	<span class="nt">callq</span>	<span class="nt">enough_arguments</span>
	<span class="cm">/* unimportant */	 
</span>  <span class="nt">movl</span>	<span class="err">$</span><span class="nt">121</span><span class="o">,</span> <span class="nv">%edi</span>
	<span class="nt">callq</span>	<span class="nt">single_argument</span>
	<span class="o">/*</span> <span class="nt">unimportant</span> <span class="o">*/</span>	   </code></pre></figure>

<p>We observe that calls to <b>enough_arguments</b> are preceed by two <b>movl</b> (with the expected numbers), whereas both <b>too_many_arguments</b> &amp; <b>single_argument</b> are only preceeded by a single <b>movl</b>. 
<br />
Hence: In release mode, there is no runtime overhead associated with unused function arguments.</p>

<p>Sideremark: In debug mode we see the expected overhead:</p>

<figure class="highlight"><pre><code class="language-sass" data-lang="sass"><span class="na">playground</span><span class="p">:</span><span class="o">:</span><span class="n">main</span><span class="o">:</span>
  <span class="cm">/* unimportant */	 	
</span>  <span class="nt">movl</span>	<span class="err">$</span><span class="nt">112</span><span class="o">,</span> <span class="nv">%edi</span>
  <span class="nt">movl</span>	<span class="err">$</span><span class="nt">113</span><span class="o">,</span> <span class="nv">%esi</span>
	<span class="nt">callq</span>	<span class="nt">too_many_arguments</span>
  <span class="cm">/* skipped */   
</span>  </code></pre></figure>

<h1>Traits</h1>

<p>The questions which motivated this post is slightly different.</p>

<p>Let’s say we have some trait:</p>

<figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">trait</span> <span class="n">DummyTrait</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">add</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="nb">u32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">u32</span><span class="p">;</span>  
<span class="p">}</span></code></pre></figure>

<p>and we have an implementor who is not using all arguments:</p>

<figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">z</span><span class="p">:</span> <span class="nb">u32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">DummyStruct</span> <span class="p">{</span>
    <span class="n">DummyStruct</span> <span class="p">{</span> <span class="n">z</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">DummyTrait</span> <span class="k">for</span> <span class="n">DummyStruct</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">add</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span> <span class="mi">_</span><span class="p">:</span> <span class="nb">u32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">u32</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.z</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">424242</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>Question: Does this lead to run-time costs?</p>

<p>The expected answer is: Since LLVM does not know about traits, it basically sees only free function, hence there is no overhead.</p>

<p>But lets look at some more assembly.
Here is the example rust: (Again, no inlining and double function calls to avoid optimizations.)</p>

<figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">trait</span> <span class="n">DummyTrait</span> <span class="p">{</span>
    <span class="nd">#[inline(never)]</span>
    <span class="k">fn</span> <span class="nf">add</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="nb">u32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">u32</span> <span class="p">{</span>
        <span class="n">y</span> <span class="o">+</span> <span class="mi">1234567</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">DummyStruct</span> <span class="p">{</span>
    <span class="n">z</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span>
<span class="p">}</span>

<span class="nd">#[inline(never)]</span>
<span class="nd">#[no_mangle]</span>
<span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">z</span><span class="p">:</span> <span class="nb">u32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">DummyStruct</span> <span class="p">{</span>
    <span class="n">DummyStruct</span> <span class="p">{</span> <span class="n">z</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">DummyTrait</span> <span class="k">for</span> <span class="n">DummyStruct</span> <span class="p">{</span>
    <span class="nd">#[inline(never)]</span>
    <span class="k">fn</span> <span class="nf">add</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span> <span class="mi">_</span><span class="p">:</span> <span class="nb">u32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">u32</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.z</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">424242</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">dummy</span> <span class="o">=</span> <span class="nf">new</span><span class="p">(</span><span class="mi">12345</span><span class="p">);</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"Result: {:?}"</span><span class="p">,</span> <span class="n">dummy</span><span class="nf">.add</span><span class="p">(</span><span class="mi">110</span><span class="p">,</span> <span class="mi">111</span><span class="p">));</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"Result: {:?}"</span><span class="p">,</span> <span class="n">dummy</span><span class="nf">.add</span><span class="p">(</span><span class="mi">112</span><span class="p">,</span> <span class="mi">113</span><span class="p">));</span>
<span class="p">}</span></code></pre></figure>

<p>and the relevant assembly:</p>

<figure class="highlight"><pre><code class="language-sass" data-lang="sass"><span class="na">playground</span><span class="p">:</span><span class="o">:</span><span class="n">main</span><span class="o">:</span>
  <span class="cm">/* unimportant */	 	
</span>	<span class="nt">movl</span>	<span class="err">$</span><span class="nt">12345</span><span class="o">,</span> <span class="nv">%edi</span>
	<span class="nt">movl</span>	<span class="err">$</span><span class="nt">110</span><span class="o">,</span> <span class="nv">%esi</span>
	<span class="na">callq</span><span class="err">	&lt;</span><span class="na">playground</span><span class="p">:</span><span class="o">:</span><span class="n">DummyStruct</span> <span class="n">as</span> <span class="n">playground</span><span class="o">::</span><span class="n">DummyTrait</span><span class="o">&gt;::</span><span class="n">add</span>
  <span class="cm">/* unimportant */	 	
</span>	<span class="nt">movl</span>	<span class="err">$</span><span class="nt">12345</span><span class="o">,</span> <span class="nv">%edi</span>
	<span class="nt">movl</span>	<span class="err">$</span><span class="nt">112</span><span class="o">,</span> <span class="nv">%esi</span>
	<span class="na">callq</span><span class="err">	&lt;</span><span class="na">playground</span><span class="p">:</span><span class="o">:</span><span class="n">DummyStruct</span> <span class="n">as</span> <span class="n">playground</span><span class="o">::</span><span class="n">DummyTrait</span><span class="o">&gt;::</span><span class="n">add</span>
  <span class="o">/*</span> <span class="nt">unimportant</span> <span class="o">*/</span></code></pre></figure>

<p>Once again, no <b>$111</b> or <b>$113</b>, so no overhead.</p>

<p>Can we see some overhead? Yes, like this:</p>

<figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">trait</span> <span class="n">DummyTrait</span> <span class="p">{</span>
    <span class="nd">#[inline(never)]</span>
    <span class="k">fn</span> <span class="nf">add</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="nb">u32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">u32</span> <span class="p">{</span>
        <span class="n">y</span> <span class="o">+</span> <span class="mi">1234567</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">DummyStruct</span> <span class="p">{</span>
    <span class="n">z</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span>
<span class="p">}</span>

<span class="nd">#[inline(never)]</span>
<span class="nd">#[no_mangle]</span>
<span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">z</span><span class="p">:</span> <span class="nb">u32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">DummyStruct</span> <span class="p">{</span>
    <span class="n">DummyStruct</span> <span class="p">{</span> <span class="n">z</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">DummyTrait</span> <span class="k">for</span> <span class="n">DummyStruct</span> <span class="p">{</span>
    <span class="nd">#[inline(never)]</span>
    <span class="k">fn</span> <span class="nf">add</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span> <span class="mi">_</span><span class="p">:</span> <span class="nb">u32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">u32</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.z</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">424242</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="nd">#[inline(never)]</span>
<span class="nd">#[no_mangle]</span>
<span class="k">fn</span> <span class="nf">overhead</span><span class="p">(</span><span class="n">d</span><span class="p">:</span><span class="o">&amp;</span><span class="n">dyn</span> <span class="n">DummyTrait</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span><span class="nb">u32</span><span class="p">,</span><span class="n">y</span><span class="p">:</span><span class="nb">u32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">u32</span> <span class="p">{</span>
    <span class="n">d</span><span class="nf">.add</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">dummy</span> <span class="o">=</span> <span class="nf">new</span><span class="p">(</span><span class="mi">12345</span><span class="p">);</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"Result: {:?}"</span><span class="p">,</span> <span class="nf">overhead</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dummy</span><span class="p">,</span> <span class="mi">114</span><span class="p">,</span> <span class="mi">115</span><span class="p">));</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"Result: {:?}"</span><span class="p">,</span> <span class="nf">overhead</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dummy</span><span class="p">,</span> <span class="mi">116</span><span class="p">,</span> <span class="mi">117</span><span class="p">));</span>
<span class="p">}</span></code></pre></figure>

<p>and the relevant assembly:</p>

<figure class="highlight"><pre><code class="language-sass" data-lang="sass"><span class="na">playground</span><span class="p">:</span><span class="o">:</span><span class="n">main</span><span class="o">:</span>
  <span class="cm">/* unimportant */	 	
</span>	<span class="nt">movl</span>	<span class="err">$</span><span class="nt">114</span><span class="o">,</span> <span class="nv">%edx</span>
	<span class="nt">movl</span>	<span class="err">$</span><span class="nt">115</span><span class="o">,</span> <span class="nv">%ecx</span>
	<span class="nt">callq</span>	<span class="nt">overhead</span>
  <span class="o">/*</span> <span class="nt">unimportant</span> <span class="o">*/</span></code></pre></figure>

<p>But here we call into an unknown trait implementation, using dynamic dispatch.
So: What else should the compiler do? <sup id="fnref:unnecessaryoptimization" role="doc-noteref"><a href="#fn:unnecessaryoptimization" class="footnote">1</a></sup></p>

<p>Last topic: Default implementation <a href="https://play.rust-lang.org/?version=stable&amp;mode=release&amp;edition=2015&amp;gist=f27cb97a33d0e85cc46877b1d799b56e">playground_2</a></p>

<figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">trait</span> <span class="n">DummyTrait</span> <span class="p">{</span>
    <span class="nd">#[inline(never)]</span>
    <span class="k">fn</span> <span class="nf">add</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="nb">u32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">u32</span> <span class="p">{</span>
        <span class="n">y</span> <span class="o">+</span> <span class="mi">1234567</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">DummyStruct2</span> <span class="p">{</span>
    <span class="n">z</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span>
<span class="p">}</span>

<span class="nd">#[inline(never)]</span>
<span class="nd">#[no_mangle]</span>
<span class="k">fn</span> <span class="nf">new2</span><span class="p">(</span><span class="n">z</span><span class="p">:</span> <span class="nb">u32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">DummyStruct2</span> <span class="p">{</span>
    <span class="n">DummyStruct2</span> <span class="p">{</span> <span class="n">z</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">DummyTrait</span> <span class="k">for</span> <span class="n">DummyStruct2</span> <span class="p">{}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">dummy2</span> <span class="o">=</span> <span class="nf">new2</span><span class="p">(</span><span class="mi">12345</span><span class="p">);</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"Result: {:?}"</span><span class="p">,</span> <span class="n">dummy2</span><span class="nf">.add</span><span class="p">(</span><span class="mi">114</span><span class="p">,</span> <span class="mi">115</span><span class="p">));</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"Result: {:?}"</span><span class="p">,</span> <span class="n">dummy2</span><span class="nf">.add</span><span class="p">(</span><span class="mi">116</span><span class="p">,</span> <span class="mi">117</span><span class="p">));</span>
<span class="p">}</span></code></pre></figure>

<p>and the relevant assembly:</p>

<figure class="highlight"><pre><code class="language-sass" data-lang="sass"><span class="na">playground</span><span class="p">:</span><span class="o">:</span><span class="n">main</span><span class="o">:</span>
  <span class="cm">/* unimportant */	 	
</span>	<span class="nt">movl</span>	<span class="err">$</span><span class="nt">115</span><span class="o">,</span> <span class="nv">%edi</span>
	<span class="na">callq</span><span class="err">	</span><span class="na">playground</span><span class="p">:</span><span class="o">:</span><span class="n">DummyTrait</span><span class="o">::</span><span class="n">add</span>
	<span class="cm">/* unimportant */
</span>  <span class="nt">movl</span>	<span class="err">$</span><span class="nt">117</span><span class="o">,</span> <span class="nv">%edi</span>
	<span class="na">callq</span><span class="err">	</span><span class="na">playground</span><span class="p">:</span><span class="o">:</span><span class="n">DummyTrait</span><span class="o">::</span><span class="n">add</span>
	<span class="o">/*</span> <span class="nt">unimportant</span> <span class="o">*/</span></code></pre></figure>

<p>Once again, we do not see any overhead. This is expected, since we still do static dispatch, so have a free function in LLVM (only the location of the function’s source code changed).</p>

<h1>Summary</h1>
<p>Let’s recall the definition of zero-cost abstraction due to Bjarne Stroustrup:
<br />
<i>What you don’t use, you don’t pay for. And further: What you do use, you couldn’t hand code any better.</i>
<br />
So we have checked:
Unused function arguments are a zero-cost abstraction in Rust.</p>

<p>Note that there is some overhead in debug mode.</p>

<p>Moreover, there is a linter warning about those parameters, which is really helpful.
Also, the tooling (i.e., rust playground or godbolt) is really nice to have. It easily allows to look at the generated assembly.</p>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:unnecessaryoptimization" role="doc-endnote">
      <p>Well, it could reason that there is only a unique implementation of DummyTrait. But this optimization seems unnecessary, since the whole point of dynamic dispatch is to support multiple implementations. <a href="#fnref:unnecessaryoptimization" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">My blog</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">My blog</li><li><a class="u-email" href="mailto:michaelvoelkl@zoho.com">michaelvoelkl@zoho.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>One more blog about software, math &amp; physics. Must content will be implemented in Rust &amp; Haskell. The default example is raytracing.    </p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
